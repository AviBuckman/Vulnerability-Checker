import subprocess, re , os
from string_checker import txtFileChecker
from csv import reader, writer

# dictionary keys
columnName = ["package", "full_path","directory","file_name" , "file_info_output", "md5", "sha1", "sha256" , "strings" ,  "readelf", "vulnerable_functions", "secret_keys"]
PACKAGE = "package"
FULL_PATH = "full_path"
DIRECTORY = "directory"
FILE_NAME = "file_name"
FILE_OUTPUT = "file_info_output"
MD5="md5"
SHA1 ="sha1"
SHA256 = "sha256"
STRINGS = "strings"
READELF = "readelf"
VULNERABLE_FUNC= "vulnerable_functions"
SECRET_KEYS = "secret_keys"

def get_directory(path):
    dir_path = os.path.dirname(path) 
    dir_name = os.path.basename(dir_path) 
    return dir_name

def get_file_name(path):
    return os.path.basename(path) 

# gets the objdump of each file and adds keywords to dictionary
def scan_binary(path):
    dump = subprocess.run(['objdump', '-D', path], stdout=subprocess.PIPE).stdout.decode('utf-8')
    found = set()
    for func_word in func_list:
        if func_word in dump:
            found.add(func_word)    
    if len(found) > 0:
        row_dict = {}
        row_dict[READELF] = subprocess.run(f"readelf -a {path}", shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
        row_dict[VULNERABLE_FUNC] = str(found)
        return row_dict
    else:
        return None

def load_functions_from_csv():
    # read csv file as a list of lists
    with open('vulnerable_functions.csv', 'r') as read_obj:
        # pass the file object to reader() to get the reader object
        csv_reader = reader(read_obj)
        # Pass reader object to list() to get a list of lists
        list_of_rows = list(csv_reader)
        return list(map(lambda x: x[0],list_of_rows))

""" params one row entry outputted by dpkg -l
    returns dictionary of library info
"""
def row_to_dictionary(row):
    field_pattern = r'\s+\S+\s+\S+\s+\S+'
    str_without_i = re.findall(field_pattern,row)[0]
    field_list= re.split(r'\s+',str_without_i)
    lib_dict = {"name":field_list[1] , "version": field_list[2], "architecture": field_list[3]}
    return lib_dict

"""
    runs linux call dpkg -l and outputs list of libraries
    each library is of form dictionary {name, version, architecture}
"""
def get_installed_libraries():
    row_pattern = r'ii\s+\S+\s+\S+\s+\S+'
    result = subprocess.run("dpkg -l",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    rows = re.findall(row_pattern,result)
    library_list = list(map(row_to_dictionary,rows))
    return library_list


def scan_library(library):
    library_name = library["name"]
    output = subprocess.run(['dpkg', '-L', library_name], stdout=subprocess.PIPE).stdout.decode('utf-8')
    path_list = output.split("\n")
    pattern = re.compile(r"\S+\.\w+$")  #this means "all strings witout spaces that end if .[a-Z]+"
    path_list_filtered = list(filter(lambda x: pattern.match(x) != None ,path_list))
    for path in path_list_filtered:
        checkPath(path, library_name)
    # pass lists to respective functions

    
"""
    param: file path 
    returns: TEXT, ELF, LINK based on file type
"""    
def get_file_type(file_info):
    if "text" in file_info:
        #ascii text executable not caught here
        #generate list of file() outputs, sort, examine --> fine tune the search
        return "TEXT"
    elif "ELF" in file_info:
        return "ELF"
    elif "symbolic link" in file_info:
        return "LINK"
    else:
        return None

        #1) check what filetype it is
        #2) if text or elf, append to list
        #3) if link
def checkPath(path, package_name):
    if len(path)>0:
        command = "file "+path
        file_info = subprocess.run(command,shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    entry_dict={}
    file_type = get_file_type(file_info)
    if file_type == "TEXT" or file_type == "ELF":
        if file_type == "TEXT":
            entry_dict = txtFileChecker(path)
            ## path + strings output + keys
        else:              
            #ELF
            entry_dict = scan_binary(path)
        if entry_dict != None:
            entry_dict[PACKAGE] = package_name
            entry_dict[FULL_PATH] = path
            entry_dict[DIRECTORY] = get_directory(path)
            entry_dict[FILE_NAME] = get_file_name(path)
            entry_dict[FILE_OUTPUT] = "file_info_output"
            md5,sha1,sha256 = get_hashes(path)
            entry_dict[MD5]= md5
            entry_dict[SHA1] = sha1
            entry_dict[SHA256] = sha256
            insert_row(entry_dict)

    elif (file_type == "LINK"):
        command="readlink -f "+path
        pointed_to = subprocess.run(command, shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
        #ASK YOTAM- not sure this is ok to do
        checkPath(pointed_to,"")
    
    
    #if entry_dict != None:
        #add package name to dict - mor
        #add directory name (just the name of immediate folder) - mor
        #file name - mor
        #add file() output
        #call hash function:
        entry_dict[SHA1]=sha1(path)
        entry_dict[SHA256]=sha256(path)
        entry_dict[MD5]=md5(path)
        #insert the dict to csv
    entry_dict[PACKAGE]=package_name
    path_file = os.path.dirname(path)
    entry_dict[DIRECTORY]=os.path.basename(path_file)
    entry_dict[FILE_NAME]=os.path.split(path)[-1]
    add_row(entry_dict)



def write_iterable_csv(iterable):
    with open('file_types.csv','w') as result_file:
        wr = writer(result_file, dialect='excel')
        wr.writerows(iterable)


"""
    row_dictionary: row- list of strings that represents row in csv to add
"""
# columnName = ["package", "full_path","directory","file_name" , "file_info_output", "md5", "sha1", "sha256" , "strings","readelf","vulnerable_functions", "secret_keys"]


def insert_row(row):
    with open('DB_file.csv', 'a+', newline='') as DB_file:
        wr = writer(DB_file, dialect='excel')
        wr.writerow(row)


def add_row(row_dictionary):
    row = [""] * 12
    i=0
    for word in columnName:
        if (row_dictionary[word] != None):
            row[i] = row_dictionary[word]
        else:
            row[i] = ""
        i+=1
    insert_row(row)

def sha1(path):
    sha1OCommand="sha1sum"+path
    sha1Output=subprocess.run(sha1OCommand, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    res=sha1Output.split(' ')
    return res[0]

def md5(path):
    md5Command="md5sum"+path
    md5Output=subprocess.run(md5Command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    res=md5Output.split(' ')
    return res[0]

def sha256(path):
    sha256Command="sha1sum"+path
    sha256Output=subprocess.run(sha256Command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    res=sha256Output.split(' ')
    return res[0]



#entry point
func_list = load_functions_from_csv()
libs = get_installed_libraries()
for lib in libs:
    scan_library(lib)



    