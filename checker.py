import subprocess
import re
import os
from string_checker import txtFileChecker
from csv import reader, writer
from db_handler import *
import logging

logging.basicConfig(filename='example.log')

# dictionary keys
PACKAGE_MANAGER = "package_manager"
PACKAGE = "package"
VERSION = "version"
FULL_PATH = "full_path"
DIRECTORY = "directory"
FILE_NAME = "file_name"
FILE_OUTPUT = "file_info_output"
MD5 = "md5"
SHA1 = "sha1"
SHA256 = "sha256"
B2 = "b2"
STRINGS = "strings"
READELF = "readelf"
VULNERABLE_FUNC = "vulnerable_functions"
SECRET_KEYS = "secret_keys"
CHECKSEC = "checksec"
C_SUFFIX = "@GLIBC"  # c_suffix differentiates between library func and user-defined func


PackageOrganized = {}
func_list = None
vul_entry_list = []
strings_entry_list = []


def main():
    global func_list
    global vul_entry_list
    global strings_entry_list
    func_list = load_functions_from_csv()
    db_handler: DBHandler = DataHandler()
    db_handler.create_tables()
    set_package_manger()
    libs = rpmOrdpkg()
    for lib in libs:
        # scan library returns list of vulnerabiliy entries and string entries
        vul_entry_list = []
        strings_entry_list = []
        scan_library(lib)
        if len(vul_entry_list) > 0:
            db_handler.insert(vul_entry_list, strings_entry_list)


def set_package_manger():
    """
        purpose: determine what linux distribution is being used and change 
                 package command dictionary accordingly
    """
    global PackageOrganized
    result = subprocess.run("whereis dpkg", shell=True,
                            stdout=subprocess.PIPE).stdout.decode('utf-8')
    if result.__contains__('/'):
        PackageOrganized = {
            "manager": "dpkg", "listOfFiles": "-L", "trackPackage": "-S", "version": "-s"}
    else:
        # meaning this is not debian distribution
        PackageOrganized = {"manager": "rpm", "listOfFiles": "-ql",
                            "trackPackage": "-qf", "version": "-qi"}


def rpmOrdpkg():
    choose = subprocess.run("whereis dpkg", shell=True,
                            stdout=subprocess.PIPE).stdout.decode('utf-8')
    if(choose.__contains__('/')):
        libs = get_installed_libraries()
        return libs
    else:
        result = subprocess.run("rpm -qa", shell=True,
                                stdout=subprocess.PIPE).stdout.decode('utf-8')
        library_list = result.split("\n")

        PackageOrganized["manager"] = "rpm"
        PackageOrganized["listOfFiles"] = "-ql"
        PackageOrganized["trackPackage"] = "-qf"
        PackageOrganized["version"] = "-qi"
        return library_list


"""
    runs linux call dpkg -l and outputs list of libraries
    each library is of form dictionary {name, version, architecture}
"""


def get_installed_libraries():
    row_pattern = r'ii\s+\S+\s+\S+\s+\S+'
    result = subprocess.run("dpkg -l", shell=True,
                            stdout=subprocess.PIPE).stdout.decode('utf-8')
    rows = re.findall(row_pattern, result)
    library_list = list(map(row_to_dictionary, rows))
    return library_list


def row_to_dictionary(row):
    """[extract from row the information of library]

    Args:
        row (str): row from the outputted by dpkg -l 

    Returns:
        dictionary: dictionary of library information : name , version , architecture
    """
    field_pattern = r'\s+\S+\s+\S+\s+\S+'
    str_without_i = re.findall(field_pattern, row)[0]
    field_list = re.split(r'\s+', str_without_i)
    lib_dict = {
        "name": field_list[1], "version": field_list[2], "architecture": field_list[3]}
    return lib_dict


def get_directory(path):
    """
    gets the directory of the file  

    Args:
        path (str): path of file to be checked

    Returns:
        str: directory name 
    """
    dir_path = os.path.dirname(path)
    dir_name = os.path.basename(dir_path)
    return dir_name


def get_file_name(path):
    return os.path.basename(path)


def scan_binary(path):
    """
    gets the objdump,checksec and readelf of each file and adds to dictionary (row_dict)

    Args:
        path (str): path of file to be checked

    Returns:
        dictionary: dictionary of file information :  READELF, VULNERABLE_FUNC , CHECKSEC
    """
    dump = subprocess.run(['objdump', '-D', path],
                          stdout=subprocess.PIPE).stdout.decode('utf-8')
    found = set()
    for func_word in func_list:
        if f"{func_word}{C_SUFFIX}" in dump:
            # c_suffix is 'GCLIB', this differentiates between library func and user-defined func
            found.add(func_word)
    row_dict = {}
    row_dict[READELF] = subprocess.run(
        f"readelf -a {path}", shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    row_dict[VULNERABLE_FUNC] = str(found) if len(found) > 0 else ""
    command = f"./checksec.sh/checksec --verbose --extended --output=csv --file={path}"
    output = subprocess.run(command, shell=True,
                            stdout=subprocess.PIPE).stdout.decode('utf-8')
    row_dict[CHECKSEC] = output
    return row_dict


def load_functions_from_csv():
    """read csv file as a list of lists , pass the file object to reader() to get the reader object
    and Pass reader object to list() to get a list of lists
    Returns:
        [list]: list of lists of rows
    """
    with open('vulnerable_functions.csv', 'r') as read_obj:
        csv_reader = reader(read_obj)
        list_of_rows = list(csv_reader)
        return list(map(lambda x: x[0], list_of_rows))


def get_library_version(name):
    """ gets the library version 

    Args:
        name (str): library name 

    Returns:
        str : version of the library
    """
    flag = PackageOrganized["version"]
    manager = PackageOrganized["manager"]
    version = subprocess.run(f"{manager} {flag} {name} | grep 'Version'",
                             shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    version = ((version.split(":"))[1]).strip(' \t\n\r')
    return version


def get_paths_files_in_library(name):
    """gets all files from a library 

    Args:
        name (str): the name of the library

    Returns:
        list: list of paths
    """
    manager = PackageOrganized["manager"]
    flag = PackageOrganized["listOfFiles"]
    output = subprocess.run(f"{manager} {flag} {name}", shell=True,
                            stdout=subprocess.PIPE).stdout.decode('utf-8')
    path_list = output.split("\n")
    path_list_filtered = list(filter(lambda x: os.path.isfile(x), path_list))
    return path_list_filtered


def scan_library(library):
    """does checkPath for each file in a library. 

    Args:
        library (str): str that represent library name 

    Returns:
        vul (list): 
        string (list): 
    """
    # TODO: ask Avi about vul and string
    manager = PackageOrganized["manager"]
    if manager == "dpkg":
        library = library['name']
    version = get_library_version(library)

    if should_scan_library(version, library, manager):
        print(
            f"scanning library {library}, version {version}, package manager = {manager}")
        path_list = get_paths_files_in_library(library)
        for path in path_list:
            checkPath(path, library, version, manager)
    else:
        print(
            f"skipping library {library}, version {version}, package manager = {manager}")


def get_file_type(path):
    """gets file type

    Args:
        path (str): the path of file
    Returns:
        str: return str that represent file type 
        str: file command output
    """
    command = f"file {path}"
    file_info = subprocess.run(
        command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    file_info = file_info.split(':')[1]
    if "text" in file_info:
        return file_info, "TEXT"
    elif "ELF" in file_info:
        return file_info, "ELF"
    elif "symbolic link" in file_info:
        return file_info, "LINK"
    else:
        return file_info, None


def exists_in_package(path: str):
    for entry in vul_entry_list:
        if entry[FULL_PATH] == path:
            return True
    return False


def checkPath(path: str, package_name: str, version: str, package_manager: str):
    """receives path and package info. Returns entry for vul table and lines if relevant 

    Returns:
        dictionary: all the information of the file for the DB
        list:  list of lines that has secert keys
    """
    if not exists_in_package(path) and should_check(path, version, package_name, package_manager):
        path = path.strip(' \t\n\r')
        if len(path) > 0:
            entry_dict = {}
            file_info, file_type = get_file_type(path)
            isTxt = file_type == "TEXT"
            isELF = file_type == "ELF"
            isLink = file_type == "LINK"
            if isTxt or isELF:
                if isTxt:
                    entry_dict, lines = txtFileChecker(
                        path, package_name, PackageOrganized["manager"], version)
                    # path + strings output + keys
                else:
                    # ELF
                    entry_dict = scan_binary(path)
                if entry_dict:
                    entry_dict[PACKAGE_MANAGER] = PackageOrganized["manager"]
                    entry_dict[PACKAGE] = package_name
                    entry_dict[VERSION] = version
                    entry_dict[FULL_PATH] = path
                    path_file = os.path.dirname(path)
                    entry_dict[DIRECTORY] = os.path.basename(path_file)
                    entry_dict[FILE_NAME] = os.path.split(path)[-1]
                    entry_dict[FILE_OUTPUT] = file_info
                    hash_dict = generate_hashes(path)
                    entry_dict[SHA1] = hash_dict[SHA1]
                    entry_dict[SHA256] = hash_dict[SHA256]
                    entry_dict[MD5] = hash_dict[MD5]
                    entry_dict[B2] = hash_dict[B2]
                    if isTxt:
                        line_list = []
                        for line in lines:
                            line_list.append({PACKAGE: entry_dict[PACKAGE],
                                              PACKAGE_MANAGER: entry_dict[PACKAGE_MANAGER],
                                              VERSION: entry_dict[VERSION],
                                              FULL_PATH: entry_dict[FULL_PATH],
                                              LINE: line})
                        vul_entry_list.append(entry_dict)
                        strings_entry_list.extend(line_list)
                    if isELF:
                        vul_entry_list.append(entry_dict)
            elif (isLink):
                pointed_to, package_name_pointed_to, package_version = scan_links(
                    path)
                checkPath(pointed_to, package_name_pointed_to,
                          package_version, PackageOrganized['manager'])


def scan_links(path):
    """gets the pointed file and its package 

    Args:
        path (str): the link path

    Returns:
        str: package name 
        str: file path
        str: package version
    """
    command = f"readlink -f {path}"
    pointed_to = subprocess.run(
        command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    pointed_to = pointed_to.strip(' \n')
    flag = PackageOrganized["trackPackage"]
    manager = PackageOrganized["manager"]
    command = f"{manager} {flag} {pointed_to}"
    package_name_pointed_to = subprocess.run(
        command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    package_name_pointed_to = package_name_pointed_to.strip(' \n')
    if manager == 'dpkg':
        package_name_pointed_to = package_name_pointed_to.split(':')[0]
    flag = PackageOrganized["version"]
    command = f"{manager} {flag} {package_name_pointed_to} | grep 'Version'"
    package_version = subprocess.run(
        command, shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    package_version = package_version.split(':')[1].strip(' \n')
    return pointed_to, package_name_pointed_to, package_version


"""
    row_dictionary: row- list of strings that represents row in csv to add
"""


def generate_hashes(path):
    """ insert to a list hashes output 

    Args:
        path (str): the file path

    Returns:
        list: list of hash output
    """
    hashes = {SHA1: "", MD5: "", SHA256: "", B2: ""}
    for key in hashes.keys():
        output = subprocess.run(
            f"{key}sum {path}", shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
        # try except error
        hashes[key] = output.split(' ')[0]
    return hashes
# entry point


if __name__ == '__main__':
    main()
