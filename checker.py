import subprocess, re , os
from string_checker import txtFileChecker
from csv import reader, writer
from db_handler import *
import logging

logging.basicConfig(filename='example.log')

# dictionary keys
PACKAGE_MANAGER="package_manager"
PACKAGE = "package"
VERSION = "version"
FULL_PATH = "full_path"
DIRECTORY = "directory"
FILE_NAME = "file_name"
FILE_OUTPUT = "file_info_output"
MD5="md5"
SHA1 ="sha1"
SHA256 = "sha256"
B2 = "b2"
STRINGS = "strings"
READELF = "readelf"
VULNERABLE_FUNC= "vulnerable_functions"
SECRET_KEYS = "secret_keys"
CHECKSEC = "checksec"
C_SUFFIX = "@GLIBC" #c_suffix differentiates between library func and user-defined func


PackageOrganized = {}
func_list = None

#TODO: python logger, try except, git ignore , delete ## . format string . alt + shift l . 
def main():
    global func_list
    func_list = load_functions_from_csv()
    create_tables()
    set_package_manger()
    libs = rpmOrdpkg()
    for lib in libs:
        scan_library(lib)



def set_package_manger():
    """
        purpose: determine what linux distribution is being used and change 
                 package command dictionary accordingly
    """
    result = subprocess.run("whereis dpkg",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    if result.__contains__('/'):
        PackageOrganized = { "manager": "dpkg","listOfFiles": "-L"  , "trackPackage": "-S" ,"version": "-s"}
    else:
        #meaning this is not debian distribution
        PackageOrganized = { "manager": "rpm","listOfFiles": "-ql"  , "trackPackage": "-qf" ,"version": "-qi"}
        
def get_list_of_libraries():

def rpmOrdpkg():
    choose = subprocess.run("whereis dpkg",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    if(choose.__contains__('/')):
        libs = get_installed_libraries()
        return libs
    else: 
        result = subprocess.run("rpm -qa",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
        library_list=result.split("\n")
        
        PackageOrganized["manager"] = "rpm"
        PackageOrganized["listOfFiles"] = "-ql"
        PackageOrganized["trackPackage"] = "-qf"
        PackageOrganized["version"] = "-qi"
        return library_list


"""
    runs linux call dpkg -l and outputs list of libraries
    each library is of form dictionary {name, version, architecture}
"""


def get_installed_libraries():
    row_pattern = r'ii\s+\S+\s+\S+\s+\S+'
    result = subprocess.run("dpkg -l",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    rows = re.findall(row_pattern,result)
    library_list = list(map(row_to_dictionary,rows))
    return library_list


""" params one row entry outputted by dpkg -l
    returns dictionary of library info
"""

def row_to_dictionary(row):
    field_pattern = r'\s+\S+\s+\S+\s+\S+'
    str_without_i = re.findall(field_pattern,row)[0]
    field_list= re.split(r'\s+',str_without_i)
    lib_dict = {"name":field_list[1] , "version": field_list[2], "architecture": field_list[3]}
    return lib_dict


def get_directory(path):
    dir_path = os.path.dirname(path) 
    dir_name = os.path.basename(dir_path) 
    return dir_name

def get_file_name(path):
    return os.path.basename(path) 

# gets the objdump of each file and adds keywords to dictionary
def scan_binary(path):
    dump = subprocess.run(['objdump', '-D', path], stdout=subprocess.PIPE).stdout.decode('utf-8')
    found = set()
    for func_word in func_list:
        if f"{func_word}{C_SUFFIX}" in dump: 
            #c_suffix is 'GCLIB', this differentiates between library func and user-defined func
            found.add(func_word)        
    row_dict = {}
    row_dict[READELF] = subprocess.run(f"readelf -a {path}", shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
    row_dict[VULNERABLE_FUNC] = str(found) if len(found) > 0 else ""
    command = f"./checksec.sh/checksec --verbose --extended --output=csv --file={path}"
    output = subprocess.run(command, shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
    row_dict[CHECKSEC] = output
    return row_dict
    

def load_functions_from_csv():
    # read csv file as a list of lists
    with open('vulnerable_functions.csv', 'r') as read_obj:
        # pass the file object to reader() to get the reader object
        csv_reader = reader(read_obj)
        # Pass reader object to list() to get a list of lists
        list_of_rows = list(csv_reader)
        return list(map(lambda x: x[0],list_of_rows))

"""
    runs linux call rpm -qa and outputs list of libraries
    
"""


def scan_library(name, version, package_manager)

def get_library_version(name):
    flag = PackageOrganized["version"]
    manager = PackageOrganized["manager"]
    version = subprocess.run(f"{manager} {flag} {name} | grep 'Version'",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    version=((version.split(":"))[1]).strip(' \t\n\r')
    return version


def get_paths_files_in_library(name)
    manager = PackageOrganized["manager"]
    flag = PackageOrganized["listOfFiles"]
    output = subprocess.run(f"{manager} {flag} {name}",shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
    path_list = output.split("\n")
    path_list_filtered = list(filter(lambda x: os.path.isfile(x) ,path_list))
    return path_list_filtered

def scan_library(library):
    flag = PackageOrganized["version"]
    manager = PackageOrganized["manager"]
    if manager == "dpkg":
        library = library['name']
    version = get_library_version(library)
    
    if should_scan_library(version, library, manager):
        print(f"scanning library {library}, version {version}, package manager = {manager}")
        path_list = get_paths_files_in_library(library)
        for path in path_list:
            checkPath(path, library, version, manager)
    else:
        print(f"skipping library {library}, version {version}, package manager = {manager}")
    # pass lists to respective functions

    
"""
    param: file path 
    returns: TEXT, ELF, LINK based on file type
"""    
def get_file_type(file_info):
    if "text" in file_info:
        #ascii text executable not caught here
        #generate list of file() outputs, sort, examine --> fine tune the search
        return "TEXT"
    elif "ELF" in file_info:
        return "ELF"
    elif "symbolic link" in file_info:
        return "LINK"
    else:
        return None

        #1) check what filetype it is
        #2) if text or elf, append to list
        #3) if link
def checkPath(path:str, package_name:str, version: str, package_manager: str):
    if should_check(path, version, package_name, package_manager):
        try:
            path = path.strip(' \t\n\r')
            if len(path)>0:
                command = "file "+path
                file_info = subprocess.run(command,shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
                file_info = file_info.split(':')[1]
                entry_dict = {}
                file_type = get_file_type(file_info)
                isTxt = file_type == "TEXT"
                isELF = file_type == "ELF"
                if isTxt or isELF:
                    if file_type == "TEXT":
                        entry_dict, lines = txtFileChecker(path, package_name, PackageOrganized["manager"], version)
                        ## path + strings output + keys
                    else:              
                        #ELF
                        entry_dict = scan_binary(path)
                    if entry_dict != None:
                        entry_dict[PACKAGE_MANAGER]=PackageOrganized["manager"]
                        entry_dict[PACKAGE] = package_name
                        entry_dict[VERSION] = version
                        entry_dict[FULL_PATH] = path
                        path_file = os.path.dirname(path)
                        entry_dict[DIRECTORY] = os.path.basename(path_file)
                        entry_dict[FILE_NAME] = os.path.split(path)[-1]
                        entry_dict[FILE_OUTPUT] = file_info
                        hash_dict = generate_hashes(path)
                        entry_dict[SHA1] = hash_dict[SHA1]
                        entry_dict[SHA256] = hash_dict[SHA256]
                        entry_dict[MD5] = hash_dict[MD5]
                        entry_dict[B2] = hash_dict[B2]
                        if isTxt:
                            insert_text(entry_dict)
                            for line in lines:
                                insert_text_to_stringLines(entry_dict, line)
                        if isELF:
                            insert_executable(entry_dict)

                elif (file_type == "LINK"):
                    command="readlink -f "+path
                    pointed_to = subprocess.run(command, shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
                    pointed_to = pointed_to.strip(' \n')

                    flag= PackageOrganized["trackPackage"]
                    manager =PackageOrganized["manager"]
                    command = f"{manager} {flag} {pointed_to}"
                    package_name_pointed_to =  subprocess.run(command,shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')           
                    package_name_pointed_to = package_name_pointed_to.strip(' \n')
                    if manager == 'dpkg':
                        package_name_pointed_to = package_name_pointed_to.split(':')[0]
                    flag= PackageOrganized["version"]
                    command = f"{manager} {flag} {package_name_pointed_to} | grep 'Version'"
                    package_version = subprocess.run(command, shell=True,stdout=subprocess.PIPE).stdout.decode('utf-8')
                    package_version = package_version.split(':')[1].strip(' \n')

                    
                    checkPath(pointed_to,package_name_pointed_to, package_version, PackageOrganized['manager'])
        except Exception as e:
            logging.warning("something raised an exception:", exc_info=True)
        
"""
    row_dictionary: row- list of strings that represents row in csv to add
"""
def generate_hashes(path):
    hashes = {SHA1: "", MD5: "", SHA256: "", B2: ""}
    for key in hashes.keys():
        output = subprocess.run(f"{key}sum {path}", shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
        #try except error 
        hashes[key] = output.split(' ')[0]
    return hashes
#entry point





if __name__ == '__main__':
    main()