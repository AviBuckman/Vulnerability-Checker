import sys
import os
import atexit
import pyodbc as driver

PACKAGE = "package"
PACKAGE_MANAGER = "package_manager"
VERSION = "version"
FULL_PATH = "full_path"
DIRECTORY = "directory"
FILE_NAME = "file_name"
FILE_OUTPUT = "file_info_output"
MD5 = "md5"
SHA1 = "sha1"
SHA256 = "sha256"
B2 = "b2"
STRINGS = "strings"
READELF = "readelf"
VULNERABLE_FUNC = "vulnerable_functions"
SECRET_KEYS = "secret_keys"
CHECKSEC = "checksec"
LINE = "line"

vulnerability_table_name = 'vulnerabilities'
class_DB_name = f'{vulnerability_table_name}.db'

strings_table_name = 'stringsLines'

databaseExisted = os.path.isfile(class_DB_name)
server = 'v-eam-server.database.windows.net'
database = 'Vulnerabilties'
username = 'namor'
password = 'EAM1234!'
db_con = driver.connect('DRIVER={ODBC Driver 17 for SQL Server};SERVER=' +
                        server+';DATABASE='+database+';UID='+username+';PWD=' + password)


def _close_db():
    db_con.commit()
    db_con.close()


atexit.register(_close_db)


def print_tables():
    print_table_by_name(table_name)


def delete():
    with db_con:
        cur = db_con.cursor()
        cur.execute("DROP TABLE " + table_name)


def print_table_by_name(table_name):
    with db_con:
        cur = db_con.cursor()
        cur.execute("SELECT * FROM  " + table_name)
        print(table_name)
        for row in cur.fetchall():
            print(row)




def create_tables():
    create_query = f"""
        IF NOT EXISTS (SELECT *   
            FROM [Vulnerabilties].INFORMATION_SCHEMA.TABLES
            WHERE TABLE_NAME = 'vulnerabilities')
                BEGIN
                    SET ANSI_NULLS ON
                    SET QUOTED_IDENTIFIER ON
                    CREATE TABLE [dbo].[vulnerabilities](
                        [package] [varchar](280) NOT NULL,
                        [package_manager] [varchar](10) NOT NULL,
                        [version] [varchar](280) NOT NULL,
                        [full_path] [varchar](280) NOT NULL,
                        [directory] [varchar](max) NOT NULL,
                        [file_name] [varchar](max) NOT NULL,
                        [file_info_output] [varchar](8000) NOT NULL,
                        [md5] [varchar](max) NOT NULL,
                        [sha1] [varchar](max) NOT NULL,
                        [sha256] [varchar](max) NOT NULL,
                        [b2] [varchar](max) NOT NULL,
                        [strings] [varchar](max) NULL,
                        [secret_keys] [varchar](max) NULL,
                        [readelf] [varchar](max) NULL,
                        [vulnerable_functions] [varchar](max) NULL,
                        [checksec] [varchar](max) NULL
                    ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
                    SET ANSI_PADDING ON
                    ALTER TABLE [dbo].[vulnerabilities] ADD PRIMARY KEY CLUSTERED 
                    (
                        [package] ASC,
                        [package_manager] ASC,
                        [version] ASC,
                        [full_path] ASC
                    )WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
                    
                    SET ANSI_NULLS ON
                    SET QUOTED_IDENTIFIER ON
                    CREATE TABLE [dbo].[stringsLines](
                        [id] [uniqueidentifier] NOT NULL,
                        [package] [varchar](280) NOT NULL,
                        [package_manager] [varchar](10) NOT NULL,
                        [version] [varchar](280) NOT NULL,
                        [full_path] [varchar](280) NOT NULL,
                        [line] [varchar](max) NOT NULL
                    ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
                    SET ANSI_PADDING ON
                    ALTER TABLE [dbo].[stringsLines] ADD PRIMARY KEY CLUSTERED 
                    (
                        [id] ASC,
                        [package] ASC,
                        [package_manager] ASC,
                        [version] ASC,
                        [full_path] ASC
                    )WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
                    ALTER TABLE [dbo].[stringsLines] ADD  DEFAULT (newid()) FOR [id]
                    ALTER TABLE [dbo].[stringsLines]  WITH CHECK ADD FOREIGN KEY([package], [package_manager], [version], [full_path])
                    REFERENCES [dbo].[vulnerabilities] ([package], [package_manager], [version], [full_path])
                END  
                """  
    exec_insert(create_query)


def insert_text_to_stringLines(string_dict, line):
    package = string_dict[PACKAGE]
    package_manager = string_dict[PACKAGE_MANAGER]
    version = string_dict[VERSION]
    full_path = string_dict[FULL_PATH]
    print(f"adding {full_path} to strings table")
    params = ['default',package, package_manager, version, full_path, line]
    query = f"""
                INSERT INTO  stringsLines(id,{PACKAGE}, {PACKAGE_MANAGER}, {VERSION}, {FULL_PATH}, {LINE})
                VALUES (?, ?, ?, ?, ?, ?)
            """
    exec_insert(query, params)


def insert_text(entry_dict):
    package = entry_dict[PACKAGE]
    package_manager = entry_dict[PACKAGE_MANAGER]
    version = entry_dict[VERSION]
    full_path = entry_dict[FULL_PATH]
    directory = entry_dict[DIRECTORY]
    file_name = entry_dict[FILE_NAME]
    file_info_output = entry_dict[FILE_OUTPUT]
    sha1 = entry_dict[SHA1]
    sha256 = entry_dict[SHA256]
    md5 = entry_dict[MD5]
    b2 = entry_dict[B2]
    strings = entry_dict[STRINGS]
    secret_keys = str(entry_dict[SECRET_KEYS])
    print(f"adding {full_path}")
    params = [package, package_manager, version, full_path, directory, file_name, file_info_output,md5, sha1, sha256, b2, strings, secret_keys]
    query = f"""INSERT INTO vulnerabilities ({PACKAGE},{PACKAGE_MANAGER}, {VERSION}, {FULL_PATH}, {DIRECTORY},
                    {FILE_NAME}, {FILE_OUTPUT}, {MD5},
                    {SHA1}, {SHA256}, {B2}, {STRINGS}, {SECRET_KEYS})
                VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)
            """
    exec_insert(query, params)


def insert_executable(entry_dict):
    package = entry_dict[PACKAGE]
    package_manager = entry_dict[PACKAGE_MANAGER]
    version = entry_dict[VERSION]
    full_path = entry_dict[FULL_PATH]
    directory = entry_dict[DIRECTORY]
    file_name = entry_dict[FILE_NAME]
    file_info_output = entry_dict[FILE_OUTPUT]
    sha1 = entry_dict[SHA1]
    sha256 = entry_dict[SHA256]
    b2 = entry_dict[B2]
    md5 = entry_dict[MD5]
    readelf = entry_dict[READELF]
    vulnerable_functions = entry_dict[VULNERABLE_FUNC]
    checksec = entry_dict[CHECKSEC]
    print(f"adding {full_path}")
    params = [package, package_manager, version, full_path, directory, file_name, file_info_output,md5, sha1, sha256, b2, readelf, vulnerable_functions, checksec]
    query = f"""
                INSERT INTO [dbo].[vulnerabilities] ({PACKAGE}, {PACKAGE_MANAGER}, {VERSION}, {FULL_PATH}, {DIRECTORY},
                    {FILE_NAME}, {FILE_OUTPUT}, {MD5},
                    {SHA1}, {SHA256}, {B2}, {READELF}, {VULNERABLE_FUNC}, {CHECKSEC})
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
    exec_insert(query, params)


def should_scan_library(version: str, package_name: str, package_manager: str)
    query = f"SELECT * FROM vulnerabilities WHERE {VERSION} = '{version}' AND {PACKAGE} = '{package_name}' AND {PACKAGE_MANAGER} = '{package_manager}'"
    result = exec_query(query)
    if(len(result) == 0):
        return True
    return False

def should_check(path: str, version: str, package_name: str, package_manager: str):
    query = f"SELECT * FROM vulnerabilities WHERE {FULL_PATH} = '{path}' AND {VERSION} = '{version}' AND {PACKAGE} = '{package_name}' AND {PACKAGE_MANAGER} = '{package_manager}'"
    result = exec_query(query)
    if(len(result) == 0):
        return True
    return False


def exec_query(query, params=None):
    with db_con:
        cur = db_con.cursor()
        if params:
            cur.execute(query, *params)
        else:
            cur.execute(query)
        rows = cur.fetchall()
        cur.close()
        return rows


def exec_insert(query, params=None):
    with db_con:
        cur = db_con.cursor()
        if params:
            cur.execute(query, *params)
        else:
            cur.execute(query)
        cur.close()
