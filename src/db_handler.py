import sys
import os
import pyodbc as driver
from data_handler import DataHandler
from defs import *


class DBHandler(DataHandler):

    def create_tables(self):
        """ executes the create tables query
        """
        with driver.connect(CONNECTION_SETTINGS) as conn:
            conn.autocommit = True
            cur = conn.cursor()
            cur.execute(CREATE_QUERY)
            cur.close()
            conn.close()

    def insert(self, vul_entry_dicts: list, string_entry_dicts: list):
        """ inserts lists of vulnerability and string entries

        Args:
            vul_entry_dicts (list): list of entries to add to vulnerability db
            string_entry_dicts (list): list of entries to add to strings db
        """
        with driver.connect(CONNECTION_SETTINGS) as conn:
            try:
                conn.autocommit = False
                cur = conn.cursor()
                self._execute_inserts(
                    vul_entry_dicts, VULNERABILITY_TABLE_NAME, cur)
                self._execute_inserts(string_entry_dicts,
                                      STRINGS_TABLE_NAME, cur)
            except driver.DatabaseError as err:
                conn.rollback()
                print(err)
                print(
                    f"rolling back\n")
            else:
                conn.commit()
            finally:
                cur.close()

    def should_scan_library(self, version: str, package_name: str, package_manager: str):
        """checks if a library was already scanned by the checker

        Args:
            version (str): package version
            package_name (str): package name
            package_manager (str): package manager
        """
        query = f"""
        SELECT * FROM {VULNERABILITY_TABLE_NAME} 
        WHERE {VERSION} = '{version}' 
        AND {PACKAGE} = '{package_name}' 
        AND {PACKAGE_MANAGER} = '{package_manager}'
        """
        result = self._execute_select(query)
        return len(result) == 0

    def should_check(self, path: str, version: str, package_name: str, package_manager: str):
        """checks if a file was already scanned by the checker

        Args:
            path (str): path of file to be checked
            version (str): package version
            package_name (str): package name
            package_manager (str): package manager
        """
        query = f"""
        SELECT * FROM {VULNERABILITY_TABLE_NAME} 
        WHERE {FULL_PATH} = '{path}' 
        AND {VERSION} = '{version}' 
        AND {PACKAGE} = '{package_name}' 
        AND {PACKAGE_MANAGER} = '{package_manager}'
        """
        result = self._execute_select(query)
        return len(result) == 0

    def _build_insert_query(self, entry_dict: dict, table_name):
        """ recieves dictionariy that represents entries in a table and creates
            an insert query based on the entry. The keys of the entry MUST be written 
            exactly as the respective column in the table

        Args:
            entry_dict (dict): dictionary that represents a db entry
            table_name ([type]): name of table to insert
        """

        column_string = ','.join(entry_dict.keys())
        q_mark_string = '?,'*len(entry_dict)
        q_mark_string = q_mark_string[:-1]
        query = f"""INSERT INTO [dbo].[{table_name}] ({column_string})
                    VALUES ({q_mark_string})
                """
        params = list(entry_dict.values())
        return query, params

    def _execute_inserts(self, entries: list, table_name: str, cursor):
        """iterates over list of entries and executes insert for each entry

        Args:
            entries (list): list of entries (dictionaries) to insert
            table_name (str): name of table to insert to
            cursor ([type]): the cursor used to insert
        """
        for entry in entries:
            try:
                query = self._build_insert_query(entry, table_name)
                cursor.execute(*query)
            except driver.DatabaseError as err:
                print(err)
                print(f'problematic entry is {str(entry)}')

    def _execute_select(self, query: str):
        """ executes the given select query and returns the corresponding rows

        Args:
            query (str): the "select" query to be executed
        """
        with driver.connect(CONNECTION_SETTINGS) as conn:
            conn.autocommit = True
            cur = conn.cursor()
            cur.execute(query)
            rows = cur.fetchall()
            cur.close()
            conn.close()
            return rows
