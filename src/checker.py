import subprocess
import os
from db_handler import DBHandler, DataHandler
from defs import *
import logging
import util_functions
from file_scanner import FileScanner


def main():
    data_handler: DataHandler = DBHandler()
    checker: Checker = Checker(data_handler)
    checker.scan_machine()


class Checker():
    def __init__(self, data_handler: DataHandler):
        self.PackageOrganized = DPKG_MAP if util_functions.is_debian() else RPM_MAP
        self.file_scanner: FileScanner = FileScanner(
            VUL_FUNC_PATH, STRINGS_PATH)
        self.data_handler: DataHandler = data_handler
        self.data_handler.create_tables()
        self.vul_entry_list = []
        self.strings_entry_list = []

    def scan_machine(self):
        libs = util_functions.get_installed_libraries_debian(
        ) if self.PackageOrganized["manager"] == "dpkg" else util_functions.get_installed_libraries_rpm
        self.scan_library_list(libs)

    def scan_library_list(self, libs: list):
        for lib in libs:
            # scan library returns list of vulnerabiliy entries and string entries
            self.vul_entry_list = []
            self.strings_entry_list = []
            self.scan_library(lib)
            if len(self.vul_entry_list) > 0:
                self.data_handler.insert(
                    self.vul_entry_list, self.strings_entry_list)

    def get_library_version(self, name):
        """ gets the library version 

        Args:
            name (str): library name 

        Returns:
            str : version of the library
        """
        flag = self.PackageOrganized["version"]
        manager = self.PackageOrganized["manager"]
        version = subprocess.run(f"{manager} {flag} {name} | grep 'Version'",
                                 shell=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
        version = ((version.split(":"))[1]).strip(' \t\n\r')
        return version

    def get_paths_files_in_library(self, name):
        """gets all files from a library 

        Args:
            name (str): the name of the library

        Returns:
            list: list of paths
        """
        manager = self.PackageOrganized["manager"]
        flag = self.PackageOrganized["listOfFiles"]
        output = subprocess.run(f"{manager} {flag} {name}", shell=True,
                                stdout=subprocess.PIPE).stdout.decode('utf-8')
        path_list = output.split("\n")
        path_list_filtered = list(
            filter(lambda x: os.path.isfile(x), path_list))
        return path_list_filtered

    def scan_library(self, library):
        """does checkPath for each file in a library. 

        Args:
            library (str): str that represent library name 

        Returns:
            vul (list): 
            string (list): 
        """
        manager = self.PackageOrganized["manager"]
        if manager == "dpkg":
            library = library['name']
        version = self.get_library_version(library)

        if self.data_handler.should_scan_library(version, library, manager):
            print(
                f"scanning library {library}, version {version}, package manager = {manager}")
            path_list = self.get_paths_files_in_library(library)
            for path in path_list:
                self.checkPath(path, library, version, manager)
        else:
            print(
                f"skipping library {library}, version {version}, package manager = {manager}")

    def exists_in_package(self, path: str):
        for entry in self.vul_entry_list:
            if entry[FULL_PATH] == path:
                return True
        return False

    """
        row_dictionary: row- list of strings that represents row in csv to add
    """

    def checkPath(self, path: str, package_name: str, version: str, package_manager: str):
        """receives path and package info. Returns entry for vul table and lines if relevant 

        Returns:
            dictionary: all the information of the file for the DB
            list:  list of lines that has secert keys
        """
        if not self.exists_in_package(path) and self.data_handler.should_check(path, version, package_name, package_manager):
            path = path.strip(' \t\n\r')
            if len(path) > 0:
                entry_dict = {}
                file_info, file_type = util_functions.get_file_type(path)
                if file_type == "TEXT" or file_type == "ELF":
                    if file_type == "TEXT":
                        entry_dict, lines = self.file_scanner.txtFileChecker(
                            path)
                        # path + strings output + keys
                    else:
                        # ELF
                        entry_dict = self.file_scanner.scan_binary(path)
                    if entry_dict:
                        self.fill_entry_dict(
                            entry_dict, path, package_name, version, package_manager, file_info)
                        self.vul_entry_list.append(entry_dict)
                        if file_type == "TEXT":
                            line_list = []
                            for line in lines:
                                line_list.append({PACKAGE: entry_dict[PACKAGE],
                                                  PACKAGE_MANAGER: entry_dict[PACKAGE_MANAGER],
                                                  VERSION: entry_dict[VERSION],
                                                  FULL_PATH: entry_dict[FULL_PATH],
                                                  LINE: line})
                            self.strings_entry_list.extend(line_list)
                elif (file_type == "LINK"):
                    pointed_to = util_functions.get_path_symb_link(path)
                    self.checkPath(pointed_to, package_name,
                                   version, package_manager)

    def fill_entry_dict(self, entry_dict: dict, path: str, package_name: str, version: str, package_manager: str, file_info: str):
        entry_dict[PACKAGE_MANAGER] = package_manager
        entry_dict[PACKAGE] = package_name
        entry_dict[VERSION] = version
        entry_dict[FULL_PATH] = path
        path_file = os.path.dirname(path)
        entry_dict[DIRECTORY] = os.path.basename(path_file)
        entry_dict[FILE_NAME] = os.path.split(path)[-1]
        entry_dict[FILE_OUTPUT] = file_info
        hash_dict = self.file_scanner.generate_hashes(path)
        entry_dict[SHA1] = hash_dict[SHA1]
        entry_dict[SHA256] = hash_dict[SHA256]
        entry_dict[MD5] = hash_dict[MD5]
        entry_dict[B2] = hash_dict[B2]


if __name__ == '__main__':
    main()
