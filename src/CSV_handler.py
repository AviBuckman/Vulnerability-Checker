from data_handler import DataHandler
from defs import *
import csv


class CSVHandler(DataHandler):
    def create_tables(self):
        """ executes the create tables query
        """
        open(VULNERABILITY_FILE_NAME, "w+")
        with open(f"{VULNERABILITY_FILE_NAME}", "a") as fp:
            wr = csv.writer(fp, dialect='excel')
            wr.writerow(TITLES)
        open(STRINGS_FILE_NAME, "w+")
        with open(f"{STRINGS_FILE_NAME}", "a") as fp:
            wr = csv.writer(fp, dialect='excel')
            wr.writerow(TITLES_STRINGS)

    def create_table(self, file_name, title):
        """ executes the create table query
        """
        open(file_name, "w+")
        with open(f"{file_name}", "a") as fp:
            wr = csv.writer(fp, dialect='excel')
            wr.writerow(title)

    def insert(self, vul_entry_dicts: list, string_entry_dicts: list):
        """ inserts lists of vulnerability and string entries

        Args:
            vul_entry_dicts (list): list of entries to add to vulnerability db
            string_entry_dicts (list): list of entries to add to strings db
        """
        self._execute_inserts(
            vul_entry_dicts, VULNERABILITY_FILE_NAME)
        self._execute_inserts(string_entry_dicts,
                              STRINGS_FILE_NAME)

    def should_scan_library(self, version: str, package_name: str, package_manager: str):
        """checks if a library was already scanned by the checker

        Args:
            version (str): package version
            package_name (str): package name
            package_manager (str): package manager
        """
        with open(VULNERABILITY_FILE_NAME) as csvfile:
            readCSV = csv.reader(csvfile, delimiter=',')
            for row in readCSV:
                pk_found = (row[1] == version) and (
                    row[2] == package_name) and (row[3] == package_manager)
                if pk_found:
                    return False
            return True

    def should_check(self, path: str, version: str, package_name: str, package_manager: str):
        """checks if a file was already scanned by the checker

        Args:
            path (str): path of file to be checked
            version (str): package version
            package_name (str): package name
            package_manager (str): package manager
        """
        with open(VULNERABILITY_FILE_NAME) as csvfile:
            readCSV = csv.reader(csvfile, delimiter=',')
            for row in readCSV:
                pk_found = (row[0] == path) and (row[1] == version) and (
                    row[2] == package_name) and (row[3] == package_manager)
                if pk_found:
                    return False
            return True

    def _execute_inserts(self, entries: list, table_name):
        """iterates over list of entries and executes insert for each entry

        Args:
            entries (list): list of entries (dictionaries) to insert
            table_name (str): name of table to insert to
        """

        row_list = list()

        # row_list = list(map(lambda entry: entry.values(), entries))
        for dic in entries:
            row = list()
            if 'line' in dic:
                for key in TITLES_STRINGS:
                    if key == 'full_path':
                        if dic[key] == '/usr/share/doc/accountsservice/TODO':
                            dic['line'] = dic['line'].split('-')[1]
                            print(dic['line'])
                    row.append(dic[key])
            else:
                for key in TITLES:
                    if key == 'secret_keys':
                        if not isinstance(dic[key], str):
                            dic[key].sort()
                            print(dic[key])
                    if key in dic:
                        if key != 'readelf' and key != 'strings' and key != 'checksec' and key != 'file_info_output':
                            row.append(dic[key])

                    else:
                        row.append("")
            row_list.append(row)
        with open(f"{table_name}", "a") as fp:
            wr = csv.writer(fp, dialect='excel')
            for row in row_list:
                # print(row)
                wr.writerow(row)

    def insertRows(self, table_name, row_list):
        with open(f"{table_name}", "a") as fp:
            wr = csv.writer(fp, dialect='excel')
            for row in row_list:
                # print(row)
                wr.writerow(row)
